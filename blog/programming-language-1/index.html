<html lang="en">
<head>
<meta 
  name    = "color-scheme" 
  content = "light dark"
/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.jessiecspencer.com/main.css">
</head>
<main >

<article>
  <h1 class="post-title">Building a programming language with Rust and MLIR part 1: pest the parser</h1>
  <span class="post-date">2023-07-17</span>
  <h2 id="overview">Overview</h2>
<p>This blog post is the first in (hopefully) a series on building and designing a programming language. For now the primary
motivation is to satisfy an urge I have To dig my teeth into language + compiler design and implementation.
I have some existing ideas for the language I plan to build, those will get a separate post.</p>
<p>The first couple of posts will serve as a sort of tutorial/introduction to the practical and theoretical aspects using the tools I have chosen (Rust, MLIR and pest).
Once the foundations have been set, I will start designing and implementing more involved aspects specific to the my language. I really need to find a name. </p>
<p>I hope you stay for the journey :)</p>
<p>The first milestone is very simple and mostly serves as a way to get our project up and running. We will start by 
building a minimal compiler that can compile: </p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#96b5b4;">println</span><span>(&quot;</span><span style="color:#a3be8c;">Hello World!</span><span>&quot;);
</span></code></pre>
<p>and have &quot;Hello World!&quot; output to standard out.</p>
<p>This should be conceptually simple enough to wrap our heads around but involved enough to kick start the project and get our compiler stack setup.</p>
<p>This first post will focus on the defining a grammar powerful enough for <code>prinln(&quot;Hello World!&quot;)</code> and generating a parser. A small introduction to compiler development
will precede the parser development, to help provide general compiler intuition for the uninitiated.</p>
<p>Before diving in, I want to make it clear that I am not(yet) an expert in compiler and language development. I have a bit of experience
from my bachelor project which involved implementing a JIT compiler for a language developed by my university. This experience made me hungry
for more and served as inspiration for all sorts of ideas I want to try out. I will make plenty of mistakes and have to learn along the way.
By documentating the process you can learn from my mistakes as well :)</p>
<p>Lets go!</p>
<h2 id="an-introduction-to-compiling-programming-languages">An introduction to compiling programming languages</h2>
<p>Before we start it is important to have some intuition around the problem space. I assume that you have experience with using a programming language. 
If not then you have my respect for starting your journey with how to build a programming language!</p>
<p>Both compiled and interpreted languages are quite common today. For example Python is a popular interpreted language and Rust is a compiled language.
We won't go deep into interpreted languages but the short version is, instead of preparing machine instructions a head of time, they are generated on
the fly as new code is fed to the interpreter. A longer explanation is found <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">here</a>. One advantage
here is that code can be run immediately without the need to invoke a compiler. This often results in poorer performance an less or no type checking at all.</p>
<p>We will be focusing on the design and implementation of a compiled language.
I am confident that a <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just in time(JIT)</a> option will be 
sufficient to support dynamic/scripting purposes. This will also force us to keep compile times low, win win. Ideally our compiler will be fast enough that normal 
ahead of time compilation is fast enough to emulate a scripting experience as well.</p>
<p>We are going to be implementing a compiler so it is important to understand what a compiler is.</p>
<p>I think compilers can take many forms not just related to programming languages. To keep things simple we will focus on programming languages.
The goal of a compiler is to take input and lower it to a different  and hopefully well optimized representation that can be executed in some target environment. You can think of C being compiled to
machine code or Java being compiled to bytecode which the  <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a> can execute. </p>
<p>This will usually involve parsing the input to build an abstract syntax tree (AST), lowering to some intermediate representation or multiple intermediate representations 
until we end up with a representation the target environment can execute. Different intermediate representations will often allow for different optimizations or checks to be performed.</p>
<p>We will start with at the beginning, parsing our input.</p>
<h2 id="the-parser">The parser</h2>
<p>The first step in our compiler pipeline is the parser. This step will build an AST and verify that the syntax is valid. 
We could implement our own lexer, and for educational purposes I think that is a good exercise. However I will be using
the PEG parsing crate <a href="https://pest.rs/">pest</a>, it is an incredible tool for generating a parser based on a PEG grammar in Rust.
This also forces us to provide a specification for our language in the form of a grammar, win win. The grammar syntax
can be a bit daunting at first.</p>
<p>To parse <code>println(&quot;Hello World!&quot;)</code> we need a few pieces of syntax in our grammar. Function calls, identifiers and values in the form of strings. 
For now will be a built in provided by the compiler, so we do not need syntax for declaring functions, only calling them.</p>
<p>Lets define strings first, we will start with the string defined for pest's JSON <a href="https://pest.rs/book/examples/json.html">example</a> and strip it down a bit.</p>
<p>Our grammar now looks like this:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// grammar.pest
</span><span>
</span><span>char = {
</span><span>    !(&quot;\&quot;&quot; | &quot;\\&quot;) ~ ANY
</span><span>}
</span><span>
</span><span>inner = @{ char* }
</span><span>
</span><span>string = ${ &quot;\&quot;&quot;	~ inner ~ &quot;\&quot;&quot; }
</span><span>
</span></code></pre>
<p>Pest has a rich syntax for specifying 
grammar. Unless you are in the habit of writing grammars often you will want to check out the the pest book 
<a href="https://pest.rs/book/grammars/grammars.html">here</a> to familiarize your self with the options. </p>
<p>We now have three rules, one for single characters <code>char</code>, one for the string contents <code>inner</code> and one for the whole string surrounded by double quotes <code>string</code>.</p>
<p>The <code>char</code> rule uses the <a href="https://pest.rs/book/grammars/syntax.html#predicates"><code>any character but</code></a> idiom. 
In our case this means if the following characters is not <code>&quot;</code> or <code>\</code> consume one character.
Looking at the char rule from left to write the <code>!</code> acts as a negation, so <code>!( &quot;\&quot;&quot; | &quot;\\&quot; )</code> says reject the patterns in the parentheses, where <code>|</code> is the 
<a href="https://pest.rs/book/grammars/syntax.html?highlight=choice#ordered-choice">choice operator</a>. This operator will try to match on the provided options from left to right. Finally if the pattern is rejected 
a single character is consumed using the builtin consumes one character denoted by the builtin <a href="https://pest.rs/book/grammars/built-ins.html"><code>ANY</code> rule</a>.</p>
<p>If you are wondering why these characters are not allowed, <code>&quot;</code> is used to define our strings and thus can not be included without being escaped 
and <code>\</code> will be used to escape characters.
Escaping these characters is not strictly necessary yet. However it does set a nice foundation and shows of more of pest. So why not? </p>
<p>A string contains an arbitrary number of characters, therefore the <code>inner</code> rule denotes exactly that with <code>char*</code>, where <code>*</code> indicates zero or more. The <code>@</code> marks this rule 
as <a href="https://pest.rs/book/grammars/syntax.html#atomic">atomic</a>. Atomic rules have the following special properties:</p>
<ol>
<li><code>~</code> means immediately follow by, so no white space. </li>
<li>Repetition operators (* and +) have no implicit separation.</li>
<li>Rules inside an atomic rule are treated as atomic.</li>
</ol>
<p>This is practical for parsing strings as we do not want to produce a token for each individual character. This also removes the implicit
allowance of white space that normal rules have with <code>~</code>. If you are wondering why have the <code>inner</code> rule at all and just put <code>char*</code> directly
inside the string rule, that is a fair question. The <code>inner</code> rule contains the contents of a string without the surrounding<code>&quot;</code>, if we removed it we would have to manually
remove the surrounding quotes.</p>
<p>We now finally get to the <code>string</code> rule. A string is delimited by <code>&quot;</code>, therefore our rule does exactly that 
<code>string = ${ &quot;\&quot;&quot;	~ inner ~ &quot;\&quot;&quot; }</code>. We look for a pair of <code>&quot;</code> with an <code>inner</code> between then. Note the <code>$</code>, it denotes <code>string</code> as
a <a href="https://pest.rs/book/grammars/syntax.html#atomic">compound atomic</a>. This ensures that no implicit white space is permitted while
still collecting the inner rules for parsing. The example below will show this in action :)</p>
<p>Lets write some Rust and test our grammar.</p>
<p>Init a cargo project, if you have not already and add the <a href="https://pest.rs"><code>pest</code></a> dependencies:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">cargo</span><span> init</span><span style="color:#bf616a;"> --bin</span><span> somelang 
</span><span style="color:#bf616a;">cargo</span><span> add pest pest_derive 
</span></code></pre>
<p>I believe that <code>cargo add</code> is a builtin option these days. If you are on an older version of cargo it can be installed with <a href="https://github.com/killercup/cargo-edit"><code>cargo-edit</code></a>. </p>
<p>Otherwise just add the dependencies manually to <code>Cargo.toml</code> as shown below :)</p>
<p>Your <code>Cargo.toml</code> should look like this:</p>
<pre data-lang="toml" style="background-color:#2b303b;color:#c0c5ce;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[dependencies]
</span><span style="color:#bf616a;">pest </span><span>= &quot;</span><span style="color:#a3be8c;">2.6</span><span>&quot;
</span><span style="color:#bf616a;">pest_derive </span><span>= &quot;</span><span style="color:#a3be8c;">2.6</span><span>&quot;
</span></code></pre>
<p>We can now jump into <code>src/main.rs</code> and use our parser. Lets start by printing what a parsed string looks like.</p>
<p>Remember to put the grammar defined earlier into <code>grammar.pest</code> in the same directory as <code>Cargo.toml</code>. Your directory should have the following structure:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Cargo.toml
</span><span>Cargo.lock
</span><span>grammar.pest
</span><span>src/main.rs
</span><span>...
</span></code></pre>
<p>In <code>main.rs</code> we:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>
</span><span style="color:#65737e;">// Add the pest depdendencies
</span><span style="color:#b48ead;">use </span><span>pest::Parser;
</span><span style="color:#b48ead;">use </span><span>pest_derive::Parser;
</span><span>
</span><span>
</span><span style="color:#65737e;">// Declare our Parser struct and derive the pest Parser trait.
</span><span style="color:#65737e;">// As well as reference the file containing our grammar.
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Parser)]
</span><span>#[</span><span style="color:#bf616a;">grammar </span><span>= &quot;</span><span style="color:#a3be8c;">grammar.pest</span><span>&quot;]
</span><span style="color:#b48ead;">pub struct </span><span>LangParser;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> input = &quot;</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#96b5b4;">\&quot;</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// This parses the &quot;hello world&quot; string using the string rule.
</span><span>    </span><span style="color:#b48ead;">let</span><span> parsed_input = LangParser::parse(Rule::string, &amp;input).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// We use #? to pretty the output for easy reading.
</span><span>    println!(&quot;</span><span style="color:#d08770;">{parsed_input:#?}</span><span>&quot;);
</span><span>}
</span><span>
</span></code></pre>
<p>Running <code>cargo run</code> should produce the following output.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>[
</span><span>    Pair {
</span><span>        rule: string,
</span><span>        span: Span {
</span><span>            str: &quot;\&quot;hello world\&quot;&quot;,
</span><span>            start: 0,
</span><span>            end: 13,
</span><span>        },
</span><span>        inner: [
</span><span>            Pair {
</span><span>                rule: inner,
</span><span>                span: Span {
</span><span>                    str: &quot;hello world&quot;,
</span><span>                    start: 1,
</span><span>                    end: 12,
</span><span>                },
</span><span>                inner: [],
</span><span>            },
</span><span>        ],
</span><span>    },
</span><span>]
</span></code></pre>
<p>Here we can see the <a href="https://docs.rs/pest/latest/pest/iterators/struct.Pair.html">Pair</a> which 
represents a matching pair of tokens and everything in between. In our case <code>&quot;</code> is the token
matched by the first Pair: <code>span: Span { str: &quot;\&quot;hello world\&quot;&quot;, start: 0, end: 13 }</code>. 
The inner field contains what ever the tokens spanned. In this case another <code>Pair</code> spanning the actual 
string contents. The matching token pair is <code>h</code> and <code>d</code>. This might seem a bit counter intuitive
but our string contains any number of <code>CHAR</code> due to <code>inner = { CHAR* }</code> and char matches
on almost any character. An important observation here is that matching tokens for a <code>Pair</code> do not need to be the same, 
only match the same rule. </p>
<p>Note how the <code>inner</code> does not contain any <code>CHAR</code> rules but just the characters it spans. 
This is due the fact that <code>inner</code> is <a href="https://pest.rs/book/grammars/syntax.html#atomic">atomic</a> and does not permit 
white space between rules. <code>string</code> on the other hand is a <a href="https://pest.rs/book/grammars/syntax.html#atomic">compound atomic</a> rule. 
It will therefore have inner rules but still does not permit any white space between matches.</p>
<h3 id="function-calls">Function calls</h3>
<p>Next up let us expand our grammar to support function calls with a single input value. This will be the last addition required to print <code>Hello World!</code>.
We will start by extending our input in <code>src/main.rs</code>.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    ...
</span><span>    </span><span style="color:#b48ead;">let</span><span> input = &quot;</span><span style="color:#a3be8c;">print(</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#96b5b4;">\&quot;</span><span style="color:#a3be8c;">)</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>();
</span><span>    ...
</span></code></pre>
<p>Now if we run <code>cargo run</code> we will get an error as our grammar does not support function calls yet. Lets fix that!</p>
<p>We will add 3 new rules, first  <code>val = _{ string }</code>. <code>val</code> represents a value. Right now we only support string values
so <code>val</code> only contains the <code>string</code> rule. <code>val</code> is silent denoted by <code>_</code>. This means that it will note be visible in our
parser. Instead we will see instances it's inner rules. This is nice as it saves us having to &quot;unwrap&quot; val instances, since we
are always interested in it's contents.</p>
<p><code>id = { ASCII_ALPHA+  }</code> will represent an identifier of variables, functions, modules etc. For example <code>println</code> is an identifier. 
<code>ASCII_ALPHA+</code> indicates matches on one or more
letters from a-z and A-Z. In future iterations we want to be support more characters but this will do for now. </p>
<p>Finally <code>call = ${ id ~  &quot;(&quot; ~ val  ~ &quot;)&quot; }</code>, which matches on a function call containing a single argument. 
<code>call</code> consists of an identifier followed by a single argument surrounded by parentheses. 
Exactly what we need! We make this rule compound atomic as we do not want white space between the 
identifier and parentheses.</p>
<p><code>grammar.pest</code> should now look like this.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// grammar.pest
</span><span>
</span><span>char = {
</span><span>    !(&quot;\&quot;&quot; | &quot;\\&quot; ) ~ ANY
</span><span>}
</span><span>
</span><span>inner = @{ char* }
</span><span>
</span><span>string = ${ &quot;\&quot;&quot;	~ inner ~ &quot;\&quot;&quot; }
</span><span>
</span><span>val = _{ string }
</span><span>
</span><span>id = { ASCII_ALPHA*  }
</span><span>
</span><span>call = ${ id ~  &quot;(&quot; ~ val  ~ &quot;)&quot; }
</span><span>
</span></code></pre>
<p>Lets take it for a spin!. Running <code>cargo run</code> should still produce an error, as we have not updated which rule we use to parse this.
In <code>src/main.rs</code> update the parsing line to use <code>Rule::call</code>. </p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#65737e;">// src/main.rs
</span><span>    ...
</span><span>    </span><span style="color:#b48ead;">let</span><span> parsed_input = LangParser::parse(Rule::call, &amp;input).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    ...
</span></code></pre>
<p>Now you should be able to run <code>cargo run</code> and get the parsed function call like this:</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>[
</span><span>    Pair {
</span><span>        rule: call,
</span><span>        span: Span {
</span><span>            str: &quot;print(\&quot;hello world\&quot;)&quot;,
</span><span>            start: 0,
</span><span>            end: 20,
</span><span>        },
</span><span>        inner: [
</span><span>            Pair {
</span><span>                rule: id,
</span><span>                span: Span {
</span><span>                    str: &quot;print&quot;,
</span><span>                    start: 0,
</span><span>                    end: 5,
</span><span>                },
</span><span>                inner: [],
</span><span>            },
</span><span>            Pair {
</span><span>                rule: string,
</span><span>                span: Span {
</span><span>                    str: &quot;\&quot;hello world\&quot;&quot;,
</span><span>                    start: 6,
</span><span>                    end: 19,
</span><span>                },
</span><span>                inner: [
</span><span>                    Pair {
</span><span>                        rule: inner,
</span><span>                        span: Span {
</span><span>                            str: &quot;hello world&quot;,
</span><span>                            start: 7,
</span><span>                            end: 18,
</span><span>                        },
</span><span>                        inner: [],
</span><span>                    },
</span><span>                ],
</span><span>            },
</span><span>        ],
</span><span>    },
</span><span>]
</span></code></pre>
<p>And with that we are finished with the grammar, for now ;)</p>
<p>This post has grown quite long so we will continue in the next one. 
Where we will actually use our parser and hopefully finish <code>prinln(&quot;Hello World!&quot;)</code>.</p>
<p>As a final step we will extract the identifier and argument, by traversing the parsed input as nested iterators.
This will help show how to work with pest.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// src/main.rs
</span><span>...
</span><span>
</span><span>    </span><span style="color:#65737e;">// Get an iterator over the pairs matched by Rule::call
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> call_pairs = parsed_input.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">next</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().</span><span style="color:#96b5b4;">into_inner</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// We know the id comes first.
</span><span>    </span><span style="color:#b48ead;">let</span><span> id = call_pairs.</span><span style="color:#96b5b4;">next</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// And the function argument second.
</span><span>    </span><span style="color:#65737e;">// We extract the `inner` rule inside the matched `string`.
</span><span>    </span><span style="color:#b48ead;">let</span><span> argument = call_pairs.</span><span style="color:#96b5b4;">next</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>().</span><span style="color:#96b5b4;">into_inner</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">id: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, argument: </span><span style="color:#d08770;">{}</span><span>&quot;, id.</span><span style="color:#96b5b4;">as_str</span><span>(), argument.</span><span style="color:#96b5b4;">as_str</span><span>());
</span><span>
</span><span>}
</span><span>
</span></code></pre>
<p><code>cargo run</code> should now produce:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">id:</span><span> print, argument: hello world
</span></code></pre>
<p>Note how <code>hello world</code> does not have surrounding quotes. This is because we went one level deeper. If we stopped at  <code>argument =  call_pairs.next().unwrap</code> we would have the <code>string</code> rule which
contains <code>&quot;</code>. By calling <code>into_inner</code> we go one rule deeper and extract the matched <code>inner</code> which only holds the contents of a 
string. </p>
<p>Traversing our parsed input in this manner will allow us to build a proper AST one we are ready. I hope this example showed how 
powerful and simple <a href="https://www.jessiecspencer.com/blog/programming-language-1/todo">pest</a> allows us to get started parsing.</p>
<h3 id="closing-notes">Closing notes</h3>
<p>Thanks for reading! I hope this post was informative and fun. The code for this post is available <a href="https://github.com/jmintb/programming_language_one">here</a>.
If you have questions or comments checkout <a href="https://github.com/jmintb/blog/discussions/1">this</a> dicussion thread.</p>
<!--[rss](https://raw.githubusercontent.com/jmintb/blog/main/atom.xml) -->
<p><a href="https://hachyderm.io/@jmintb">mastodon</a>
<a href="https://github.com/jmintb">github</a>
<a href="https://www.youtube.com/channel/UCiktIroKtzNNLqyRgPxvnfQ">youtube</a>
<a href="https://www.twitch.tv/teainspace">twitch</a>
<a href="mailto:jessie@teainspace.com">email</a></p>

</article>

</main>
</html>
